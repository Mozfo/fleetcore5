// Driver Documents API routes: POST /api/v1/drivers/:id/documents (create) and GET /api/v1/drivers/:id/documents (list)
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { DriverService } from "@/lib/services/drivers/driver.service";
import { driverDocumentSchema } from "@/lib/validators/drivers.validators";
import { ValidationError, NotFoundError } from "@/lib/core/errors";

/**
 * POST /api/v1/drivers/:id/documents
 * Create a new document for a driver
 *
 * Workflow (2-step transaction):
 * 1. Create doc_documents (WITHOUT created_by, updated_by - these fields don't exist in this table)
 * 2. Create rid_driver_documents (WITH created_by, updated_by - audit fields exist here)
 *
 * Intentional duplication: document_type, expiry_date, verified exist in both tables
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // 1. Extract headers (injected by middleware)
    const userId = request.headers.get("x-user-id");
    const tenantId = request.headers.get("x-tenant-id");

    if (!userId || !tenantId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Await params (Next.js 15 convention)
    const { id } = await params;

    // 3. Parse and validate request body
    const body = await request.json();
    const validatedData = driverDocumentSchema.parse(body);

    // 4. Verify driver exists
    const driverService = new DriverService();
    const driver = await driverService.getDriver(id, tenantId);

    if (!driver) {
      return NextResponse.json({ error: "Driver not found" }, { status: 404 });
    }

    // 5. Create document in transaction (2 steps for atomicity)
    const result = await driverService["prisma"].$transaction(async (tx) => {
      // STEP 1: Create doc_documents (WITHOUT audit fields created_by, updated_by)
      const docDocument = await tx.doc_documents.create({
        data: {
          tenant_id: tenantId,
          entity_type: "driver",
          entity_id: id,
          file_url: validatedData.file_url,
          document_type: validatedData.document_type,
          issue_date: validatedData.issue_date,
          expiry_date: validatedData.expiry_date,
          verified: validatedData.verified || false,
          // created_at, updated_at auto-generated by Prisma
        },
      });

      // STEP 2: Create rid_driver_documents (WITH audit fields)
      const driverDocument = await tx.rid_driver_documents.create({
        data: {
          tenant_id: tenantId,
          driver_id: id,
          document_id: docDocument.id, // Reference to doc_documents
          document_type: validatedData.document_type, // Intentional duplication
          expiry_date: validatedData.expiry_date, // Intentional duplication
          verified: validatedData.verified || false, // Intentional duplication
          created_by: userId, // Audit field (exists only in rid_driver_documents)
          updated_by: userId, // Audit field (exists only in rid_driver_documents)
          // created_at, updated_at auto-generated
        },
        include: {
          doc_documents: true, // Include related doc_documents in response
        },
      });

      return driverDocument;
    });

    // 6. Return created document
    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation failed", details: error.issues },
        { status: 400 }
      );
    }
    if (error instanceof ValidationError) {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }
    if (error instanceof NotFoundError) {
      return NextResponse.json({ error: error.message }, { status: 404 });
    }
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * GET /api/v1/drivers/:id/documents
 * List all documents for a driver
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // 1. Extract headers (injected by middleware)
    const userId = request.headers.get("x-user-id");
    const tenantId = request.headers.get("x-tenant-id");

    if (!userId || !tenantId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Await params (Next.js 15 convention)
    const { id } = await params;

    // 3. Query driver documents with Prisma
    const driverService = new DriverService();
    const documents = await driverService[
      "prisma"
    ].rid_driver_documents.findMany({
      where: {
        driver_id: id,
        tenant_id: tenantId,
        deleted_at: null,
      },
      include: {
        doc_documents: true, // Include related doc_documents for file_url, etc.
      },
      orderBy: {
        created_at: "desc",
      },
    });

    // 4. Return documents list
    return NextResponse.json(documents, { status: 200 });
  } catch (error) {
    if (error instanceof NotFoundError) {
      return NextResponse.json({ error: error.message }, { status: 404 });
    }
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
