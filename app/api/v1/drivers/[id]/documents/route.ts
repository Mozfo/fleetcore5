// Driver Documents API routes: POST /api/v1/drivers/:id/documents (create) and GET /api/v1/drivers/:id/documents (list)
import { NextRequest, NextResponse } from "next/server";
import { DriverService } from "@/lib/services/drivers/driver.service";
import { driverDocumentSchema } from "@/lib/validators/drivers.validators";
import { handleApiError } from "@/lib/api/error-handler";

/**
 * POST /api/v1/drivers/:id/documents
 * Create a new document for a driver
 *
 * Workflow (2-step transaction):
 * 1. Create doc_documents (WITHOUT created_by, updated_by - these fields don't exist in this table)
 * 2. Create rid_driver_documents (WITH created_by, updated_by - audit fields exist here)
 *
 * Intentional duplication: document_type, expiry_date, verified exist in both tables
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  // 1. Extract auth headers (before try for error context)
  const userId = request.headers.get("x-user-id");
  const tenantId = request.headers.get("x-tenant-id");

  try {
    // 2. Auth check
    if (!userId || !tenantId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 3. Await params (Next.js 15 convention)
    const { id } = await params;

    // 4. Parse and validate request body
    const body = await request.json();
    const validatedData = driverDocumentSchema.parse(body);

    // 5. Verify driver exists
    const driverService = new DriverService();
    const driver = await driverService.getDriver(id, tenantId);

    if (!driver) {
      return NextResponse.json({ error: "Driver not found" }, { status: 404 });
    }

    // 6. Create document in transaction (2 steps for atomicity)
    const result = await driverService["prisma"].$transaction(async (tx) => {
      // STEP 1: Create doc_documents (WITHOUT audit fields created_by, updated_by)
      const docDocument = await tx.doc_documents.create({
        data: {
          tenant_id: tenantId,
          entity_type: "driver",
          entity_id: id,
          file_url: validatedData.file_url,
          document_type: validatedData.document_type,
          issue_date: validatedData.issue_date,
          expiry_date: validatedData.expiry_date,
          verified: validatedData.verified || false,
          // created_at, updated_at auto-generated by Prisma
        },
      });

      // STEP 2: Create rid_driver_documents (WITH audit fields)
      const driverDocument = await tx.rid_driver_documents.create({
        data: {
          tenant_id: tenantId,
          driver_id: id,
          document_id: docDocument.id, // Reference to doc_documents
          document_type: validatedData.document_type, // Intentional duplication
          expiry_date: validatedData.expiry_date, // Intentional duplication
          verified: validatedData.verified || false, // Intentional duplication
          created_by: userId, // Audit field (exists only in rid_driver_documents)
          updated_by: userId, // Audit field (exists only in rid_driver_documents)
          // created_at, updated_at auto-generated
        },
        include: {
          doc_documents: true, // Include related doc_documents in response
        },
      });

      return driverDocument;
    });

    // 7. Return created document
    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    return handleApiError(error, {
      path: request.nextUrl.pathname,
      method: "POST",
      tenantId: tenantId || undefined,
      userId: userId || undefined,
    });
  }
}

/**
 * GET /api/v1/drivers/:id/documents
 * List all documents for a driver
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  // 1. Extract auth headers (before try for error context)
  const userId = request.headers.get("x-user-id");
  const tenantId = request.headers.get("x-tenant-id");

  try {
    // 2. Auth check
    if (!userId || !tenantId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 3. Await params (Next.js 15 convention)
    const { id } = await params;

    // 4. Query driver documents with Prisma
    const driverService = new DriverService();
    const documents = await driverService[
      "prisma"
    ].rid_driver_documents.findMany({
      where: {
        driver_id: id,
        tenant_id: tenantId,
        deleted_at: null,
      },
      include: {
        doc_documents: true, // Include related doc_documents for file_url, etc.
      },
      orderBy: {
        created_at: "desc",
      },
    });

    // 5. Return documents list
    return NextResponse.json(documents, { status: 200 });
  } catch (error) {
    return handleApiError(error, {
      path: request.nextUrl.pathname,
      method: "GET",
      tenantId: tenantId || undefined,
      userId: userId || undefined,
    });
  }
}
